% !TEX root = ../Projektdokumentation.tex
\section{Implementierungsphase}
\label{sec:Implementierungsphase}

\subsection{Einleitung}
\label{sec:Einleitung}
Nach der Planungsphase wurde im direkten Anschluss die Implementierungsphase mit folgenden Schritten
eingeleitet:
\begin{enumerate}
	\item Implementierung des Backends (Datenbank, Controllerlogik, Administratorbereich)
	\item Implementierung der Benutzeroberfläche (Bootstrap, Tab-Layout)
	\item Anbindung externer Schnittstellen (Github API (octokit), LDAP-Authentifizierung (devise))
	\item Implementierung der internen Schnittstelle (rabl-gem)
	\item Durchführung einer Testphase
	\item Paketierung der Applikation (Schreiben des Specfiles, Patch)
	\item Deployment auf Produktivmaschine (Konfigurieren des Apache-Webservers, vhost, SSL)
\end{enumerate}

\subsection{Implementierung des Backends}
\label{sec:Implementierung des Backends}
Die Entwicklung der Applikation begann mit der initialen Erstellung eines \acs{RoR}-Projektes.
Nach Installation der zugehörigen Entwicklungsumgebung geschieht dies einfach mit Ausführung des
Befehls \Code{rails new} in dem gewünschten Verzeichnis. Mit Hilfe dieses Befehls wird eine standardisierte
Projektmappe erzeugt.

Hier sei anzumerken dass RoR viele eingebaute Befehle mitbringt, welche die Ausführung von
Entwicklungsschritten, wie \bspw das Anlegen von bestimmten Klassen, automatisiert. Ein manuelles
Anlegen von relevanten Dateien im korrekten Verzeichnis entfällt dadurch und der Entwicklungsprozess
kann massiv beschleunigt werden.

Das \textit{Gemfile} bildet die zentrale Auflistung der von der Applikation genutzten Gems. Da die
Entwicklung der Applikation im Sinne des \acs{TDD} (\Vgl \ref{sec:Entwicklungsprozess}) erfolgt, wurde hier zunächst die Testsuite
\textit{rspec} hinzugefügt und die ersten Tests für die Models (\Vgl \ref{sec:Architekturdesign})
geschrieben.

\subsubsection{Erstellen der Models}
\label{sec:Erstellen der Models}
Erst nach Schreiben der Tests erfolgte die Erstellung der eigentlichen Modeldateien. samt jeweils
zugehörigen Attributen. Zum Hinzufügen zur Datenbank wird der Befehl \Code{rake db:migrate} ausgeführt, welcher
die Ruby-Syntax in \textit{\acs{SQL}} übersetzt.

Um die Integrität der Datenbanktabellen zu erhalten und \ggfs Falscheingaben des Anwenders abzufangen,
werden in den Models Validierungen implementiert. Diese werden bei jeder Datenbankoperation
ausgeführt und verhindern bei Eingabe fehlerhafter Daten ein Abspeichern in der Datenbank.

TODO: insert code example of user model validation/tool model validation

Im Anschluss dessen wurde eine weitere \textit{Migration} ausgeführt, welche ein Typ-Attribut zu
beiden Models hinzufügt. Dadurch wurde die in der Projektplanung niedergelegte Vererbungsstrategie
der \acs{STI} realisiert (\Vgl \ref{sec:Datenmodell}).

\subsubsection{Erstellen der Controller}
\label{sec:Erstellen der Controller}
Wie auch bei den Models erfolgt vor Erstellung der Controller das Schreiben von Tests, in denen die
grundlegend erwarteten Verhaltensweisen der Controller getestet werden.

Das Kernstück der Applikation bildet der \textit{Application Controller}. In diesem wurden
verschiedene Strategien implementiert, welche den Betrieb der gesamten Applikation betreffen,
\bspw das initiale Aufrufen der Nutzerauthentifizierung. Alle anderen Controller erben von diesem
Application Controller und verfügen damit bei Aufruf über alle dort niedergelegten Methoden.

Per Konvention wird für jedes Model mindestens ein Controller erstellt, jedoch benötigt nicht jeder
Controller ein Model. In jedem Controller befinden sich sogenannte \textit{Actions}. Ruft der Nutzer \bspw die Webseite
zum Hinzufügen eines neuen Alias für einen externen Service auf, wird seine Anfrage an die
\Code{new}-Action des jeweiligen Controllers weitergeleitet (\Vgl \ref{sec:Architekturdesign}).

Zunächst wird der \textit{ExternaltoolsController} erstellt. Alle relevanten Datenbankoperationen
wie Anzeige, Hinzufügen und Löschen von Daten des Tool-Models werden von diesem Controller
verarbeitet. Dazu fragt der Controller Informationen zu dem eingeloggten Nutzer aus der User-Tabelle
ab, welches über das Objekt \Code{current user} realisiert wird. Dieses Objekt stammt aus dem
eingesetzten Authentifizierungs-Gem \textit{Devise} (\Vgl \ref{sec:Anbindung externer Schnittstellen}).

TODO: code example of externaltools controller

Anschließend werden in einem Unterverzeichnis die Controller für den Administratorbereich der
Applikation angelegt. Um diese vor einem unberechtigten Aufruf zu schützen, wird ein
\textit{AdminController} erstellt, dessen einzige Methode prüft, ob ein Administrator eingeloggt ist.
Ist dies nicht der Fall, erfolgt eine Weiterleitung zur Index-Seite.

Da nur die Administratoren die Möglichkeit besitzen sollen, Nutzer aus der Datenbank zu entfernen,
befindet sich der \textit{UsersController} in diesem Unterverzeichnis. Das Kernstück dieses
Controllers ist die \Code{list user}-Action, welche die gesammelten Informationen zu allen
Mitarbeitern aus der Datenbank abfragt und die API bereitstellt.

TODO: code example of users controller

In ähnlicher Weise wird der \textit{UnderlingsController} implementiert, welcher aber nur
Informationen zu Teammitgliedern abfragt.

\subsection{Implementierung der Benutzeroberfläche}
\label{sec:Implementierung der Benutzeroberfläche}
\begin{itemize}
	\item Schreiben von Feature-Tests (capybara) (code example)
	\item Einbindung von Bootstrap
	\item Gestaltung des Layouts als Dashboard, Panel und Tabelemente (LH?) (screenshot)
	\item Nutzung von Partials zur Verringerung der Response-Time
	\item Admin-Tabs nur sichtbar und anzeigbar wenn als Admin authentifiziert (controller-restrained)
\end{itemize}

\subsection{Anbindung externer Schnittstellen}
\label{sec:Anbindung externer Schnittstellen}
\begin{itemize}
	\item Everybody loves tests
	\item LDAP-Konfiguration für Devise zur Mitarbeiterauthentifizierung
	\item first login: Abfrage statischer Informationen wie Name, Firmenemail, Standort; Speichern in DB
	\item bei jedem weiteren Login: dynamische Abfrage des Managers (auch bei Detailansicht in Admin-View)
	\item dynamische Abfrage des Mitarbeiterstatus einmal wöchentlich
	\item Team-view
	\item vgl. entwickelte LDAP-Methode (code example)
	\item Github/Octokit: Abfrage der Organisationszugehörigkeit und Anzeige von mailto an admins
	\item Gleiche Methode für Trello auf Grund von Zeitmangel nicht mehr implementiert
	\item Sidekiq/Sidetiq Jobs (code example)
\end{itemize}

\subsection{Interne Schnittstelle}
\label{sec:Interne Schnittstelle}
\begin{itemize}
	\item Test it!
	\item Formatierung des JSON-Outputs für etsync
	\item Controller response to JSON
	\item rabl-gem zur einfachen Formatierung von JSON mit einfachen Active Record-Queries
	\item Da in Admin-Namespace nur ansprechbar bei Authentifizierung als Administrator
\end{itemize}

\subsection{Testphase}
\label{sec:Testphase}
\begin{itemize}
	\item Gering gehalten, da TDD inkl. Feature-Tests
	\item Rerun der Testsuite
	\item Manueller Testrun mit Usern zum Test der GUI
\end{itemize}

\subsection{Paketierung}
\label{sec:Paketierung}
\begin{itemize}
	\item rpm
	\item specfile (excerpt of specfile)
	\item Automatisierung der Paketierung bei neuem Commit in Repository, nach Run der Tests
	\item Hält Paket auf neuestem Stand
\end{itemize}

\subsection{Deployment}
\label{sec:Deployment}
\begin{itemize}
	\item Deployment in Kollaboration mit SUSE IT-Team, Bereitstellung der Produktivmaschine und
	Produktivdatenbank
	\item Konfigurieren eines Apache-Servers für vhosts
	\item Manuelle Installation der Applikation auf Produktivmaschine
\end{itemize}

% \subsection{Implementierung der Datenstrukturen}
% \label{sec:ImplementierungDatenstrukturen}
%
% \begin{itemize}
% 	\item Beschreibung der angelegten Datenbank (\zB Generierung von \acs{SQL} aus Modellierungswerkzeug oder händisches Anlegen), \acs{XML}-Schemas \usw.
% \end{itemize}
%
%
% \subsection{Implementierung der Benutzeroberfläche}
% \label{sec:ImplementierungBenutzeroberflaeche}
%
% \begin{itemize}
% 	\item Beschreibung der Implementierung der Benutzeroberfläche, falls dies separat zur Implementierung der Geschäftslogik erfolgt (\zB bei \acs{HTML}-Oberflächen und Stylesheets).
% 	\item \Ggfs Beschreibung des Corporate Designs und dessen Umsetzung in der Anwendung.
% 	\item Screenshots der Anwendung
% \end{itemize}
%
% \paragraph{Beispiel}
% Screenshots der Anwendung in der Entwicklungsphase mit Dummy-Daten befinden sich im \Anhang{Screenshots}.
%
%
% \subsection{Implementierung der Geschäftslogik}
% \label{sec:ImplementierungGeschaeftslogik}
%
% \begin{itemize}
% 	\item Beschreibung des Vorgehens bei der Umsetzung/Programmierung der entworfenen Anwendung.
% 	\item \Ggfs interessante Funktionen/Algorithmen im Detail vorstellen, verwendete Entwurfsmuster zeigen.
% 	\item Quelltextbeispiele zeigen.
% 	\item Hinweis: Wie in Kapitel~\ref{sec:Einleitung}: \nameref{sec:Einleitung} zitiert, wird nicht ein lauffähiges Programm bewertet, sondern die Projektdurchführung. Dennoch würde ich immer Quelltextausschnitte zeigen, da sonst Zweifel an der tatsächlichen Leistung des Prüflings aufkommen können.
% \end{itemize}
%
% \paragraph{Beispiel}
% Die Klasse \texttt{Com\-par\-ed\-Na\-tu\-ral\-Mo\-dule\-In\-for\-ma\-tion} findet sich im \Anhang{app:CNMI}.
%
%
% \Zwischenstand{Implementierungsphase}{Implementierung}
