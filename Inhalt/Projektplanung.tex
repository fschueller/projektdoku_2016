% !TEX root = ../Projektdokumentation.tex
\section{Projektplanung}
\label{sec:Projektplanung}

\subsection{Zeitplanung}
\label{sec:Zeitplanung}
Für das Projekt wurde folgende Zeitplanung aufgestellt:

\tabelle{Zeitplanung}{tab:Zeitplanung}{ZeitplanungKomplett}

\subsection{Ressourcenplanung}
\label{sec:Ressourcenplanung}
\subsubsection{Personalplanung}
\label{sec:Personalplanung}
Außer dem Auszubildenden werden keine weiteren Mitarbeiter für das Projekt eingesetzt. Dieser wird
dafür von seiner regulären Mitarbeit im Team freigestellt. Einen Sonderstatus nimmt dabei der
Projektverantwortliche ein. Im Bezug auf Anforderungen nimmt er eine kundenähnliche Rolle ein,
ist aber ansonsten nicht in die Entwicklung involviert.
\pagebreak
\subsubsection{Kostenplanung}
\label{sec:Kostenplanung}
Um die Übersichtlichkeit zu erhöhen, werden die Kosten wie folgt gegliedert und erläutert:
\begin{itemize}
	\item \textbf{Personalkosten}: Belaufen sich auf die Höhe der Ausbildungsvergütung für den Zeitraum des Projekts.
	\item \textbf{Entwicklungskosten}: Belaufen sich auf Summe der anfallenden Kosten für die Entwicklung der Applikation.
	Hierzu gehören notwendige IT, Internetanschluss, Büro usw. Im Zuge dieses Projektes lassen sich die Kosten nicht
	von den regulären Betriebskosten des Unternehmens trennen. Sie werden daher der Einfachheit halber für das Projekt als gegeben
	angesehen.
	\item \textbf{Softwarelizenzen}: Durch die ausschließliche Nutzung einer Entwicklungsumgebung und Werkzeugen aus dem
	Open-Source-Bereich entstehen keine zusätzlichen Kosten.
\end{itemize}

\subsection{Entwicklungsprozess}
\label{sec:Entwicklungsprozess}
Als Entwicklungsmethode wird \textit{Test Driven Development} (\acs{TDD}) eingesetzt. Diese Methode
sieht vor, dass vor dem Schreiben des eigentlichen Quellcodes zuerst der
dazugehörige Test entwickelt wird. Dadurch wird ein abstrakter und
zielorientierter Blick auf die eigentlichen Anforderungen an die Applikation ermöglicht.
Hierbei wird als erstes eine Überlegung über das Ergebnis einer Funktion angestellt und darauf
aufbauend die eigentliche Implementierung des jeweiligen Algorithmus gestartet, welcher das gewünschte
Ergebnis erzielen soll.

Neben den Tests für den Quellcode werden ebenfalls Tests für die Benutzeroberfläche entwickelt.

\subsection{Architekturdesign}
\label{sec:Architekturdesign}
Zur Umsetzung der geforderten Modularität der Applikation wurde das sogenannte
\anf{Model-View-Controller-Schema} (\acs{MVC}) verwendet. Dieses ist ein gängiges Schema beim Aufbau von
Webapplikationen und besteht aus drei Teilen:
\begin{itemize}
	\item das \textbf{Model}, welches grob die einzelnen Tabellen einer Datenbank repräsentiert. Es enthält in
	der Regel zusätzliche Logik und Regeln, die zur Verwaltung und Zusammensetzung von Attributen
	eines Datenbankobjektes notwendig sind.
	\item der \textbf{View}, welcher eine Ausgabe der gewünschten Daten bereitstellt. Im Kontext einer
	Webapplikation ist dies die eigentlich dargestellte Webseite in \acs{HTML}/\acs{CSS}.
	\item der \textbf{Controller}, welcher die Schnittstelle zwischen Model und View darstellt.
	Im Controller werden Eingaben verarbeitet und Befehle an das Model weitergegeben, welche
	die angeforderten Informationen an den Controller zurückgibt, der diese wiederum an den
	entsprechenden View verteilt.
\end{itemize}
Über diese Aufteilung ist eine strukturierte und übersichtliche Entwicklung möglich. Funktionslogik,
Datenbankoperationen und Ausgabelogik werden klar getrennt und können jeweils namentlich zugehörig
gekennzeichnet werden.

\abb{MVC-Schema}{fig:MVC-Schema}{MVC-Model.pdf}{0.5}

\subsection{Wahl der Programmiersprache}
\label{sec:Wahl der Programmiersprache}
Als Programmiersprache wurden \textit{Ruby} und sein Web-Framework \textit{Ruby on Rails} (RoR) gewählt.
Die entscheidenden Aspekte werden im folgenden Absatz erläutert.

Die objektorientierte Programmiersprache Ruby legt Wert auf die Balance von \textit{funktionaler} und
\textit{imperativer Programmierung}. So verzichtet Ruby beispielsweise auf Klammern zur Kennzeichnung
von Codeblöcken und behandelt jeden Bestandteil des Codes, wie beispielsweise Variablen, als ein \textit{Objekt},
welches eigene Methoden besitzt. Das macht die Verarbeitung und Manipulation von Informationen sehr
intuitiv und leicht nachvollziehbar. Zusätzlich werden Ruby und \acs{RoR}
quelloffen verwaltet sowie entwickelt und sind gut dokumentiert.

Neben den vorhandenen Programmbibliotheken existieren zusätzlich von der Community bereitgestellte Module,
sogenannte \textit{Gems}. Die Einbindung dieser Gems in ein bestehendes Projekt vermeidet
Duplikation und erspart viel Entwicklungszeit.

\subsection{Benutzeroberfläche}
\label{sec:Benutzeroberfläche}
Da es sich um kein teamübergreifendes Projekt handelt und möglichst zeiteffizient
eine für Nutzer verständliche Oberfläche realisiert werden muss, fiel die Entscheidung auf
\textit{Twitter Bootstrap}.
Das CSS-Framework Twitter Bootstrap wird häufig zur Gestaltung von Webseiten und
-applikationen verwendet, da es ein über eine umfangreiche Bibliothek an Gestaltungsvorlagen
verfügt und sehr leicht in ein Projekt zu integrieren ist.

\subsection{Rechteverteilung}
\label{sec:Rechteverteilung}
Die Applikation wird durch zwei verschiedenen Arten von Usern verwendet:
\begin{itemize}
	\item Den regulären Mitarbeitern, die einzig Zugriff auf die eigenverwalteten Informationen über die jeweiligen externen Services haben
	\item Den Administratoren, die alle Datensätze der in der Datenbank vorhandenen Mitarbeiter einsehen, abfragen und löschen können.
\end{itemize}
Die Rechteverwaltung kann mittels des Einsatzes von \textit{Flags} realisiert werden, welches auch
die einfachste Methode darstellt. Aus Sichtweise der IT-Sicherheit ist diese jedoch nicht optimal,
da eine Manipulation nicht auszuschließen ist. Daher wurde entschieden, die Rechteverteilung auf
Datenbankebene zu realisieren.

\subsection{Datenmodell}
\label{sec:Datenmodell}
Das Projekt verfügt über zwei Informationsträger, die in der Datenbank abgebildet werden
sollen: den User-Objekten und den jeweils zugehörigen Tool-Objekten.

\abb{Datenmodell}{fig:Datenmodell}{data-model.pdf}{0.6}

Da für die Applikation zusätzliche Spezialisierungen der Datenbankobjekte notwendig sind, werden
diese Beziehungen mit Hilfe der sogenannten \textit{Single Table Inheritance} (\acs{STI}) realisiert.
Damit können beispielsweise unterschiedliche externe Tools in der Datenbank abgebildet werden.

\abb{Beispielhafte Darstellung der STI}{fig:STI-Beispiel}{STI-Figure.pdf}{0.5}

Diese spezielle Vererbungsstrategie lässt sich mit Hilfe der in Rails eingebauten
\textit{Active Record}-Engine umsetzen, d.h. durch das einfache Hinzufügen eines Typ-Attributs an das Model.

\subsection{Schnittstellen}
\label{sec:Schnittstellen}
Die Hauptaufgabe der Applikation ist die Bereitstellung der gesammelten Informationen zu den
Mitarbeitern und deren eingetragenen Informationen zu ihren genutzten Services. Dazu soll eine
eigene Schnittstelle innerhalb der Applikation entwickelt werden, welche die Informationen im
JSON-Format ausgibt. Diese Schnittstelle kann nur von einem Administrator angesprochen
werden, der sich zuvor als solcher bei der Applikation authentisiert hat.

\abb{Visualisierung der internen Schnittstelle}{fig:etsync-api}{etsync-api.pdf}{0.6}

\subsection{Paketierung}
\label{sec:Paketierung}

Entsprechend der Richtlinien der SUSE-IT müssen entwickelte
Applikationen als \textit{RPM Package Manager}-Paket (\acs{RPM}) gebaut und bereitgestellt werden. Dies
ermöglicht eine einfache und automatisierbare Installation, da alle
notwendigen Programmabhängigkeiten im Paket definiert werden und durch
die eingesetzte Paketverwaltungs-Software automatisch aufgelöst und
nachinstalliert werden können.
