% !TEX root = ../Projektdokumentation.tex
\section{Projektplanung}
\label{sec:Projektplanung}


\subsection{Projektphasen}
\label{sec:Projektphasen}

TODO: enter planning table here

% \begin{itemize}
% 	\item In welchem Zeitraum und unter welchen Rahmenbedingungen (\zB Tagesarbeitszeit) findet das Projekt statt?
% 	\item Verfeinerung der Zeitplanung, die bereits im Projektantrag vorgestellt wurde.
% \end{itemize}
%
% \paragraph{Beispiel}
% Tabelle~\ref{tab:Zeitplanung} zeigt ein Beispiel für eine grobe Zeitplanung.
% \tabelle{Zeitplanung}{tab:Zeitplanung}{ZeitplanungKurz}\\
% Eine detailliertere Zeitplanung findet sich im \Anhang{app:Zeitplanung}.
%
%
% \subsection{Abweichungen vom Projektantrag}
% \label{sec:AbweichungenProjektantrag}
%
% \begin{itemize}
% 	\item Sollte es Abweichungen zum Projektantrag geben (\zB Zeitplanung, Inhalt des Projekts, neue Anforderungen), müssen diese explizit aufgeführt und begründet werden.
% \end{itemize}

\subsection{Ressourcenplanung}
\label{sec:Ressourcenplanung}
\subsubsection{Personalplanung}
\label{sec:Personalplanung}
Das für die Entwicklung benötigte Personal besteht aus einem Auszubildenden, der dafür von seiner
regulären Mitarbeit im derzeitigen Team freigestellt wird.
\subsubsection{Kostenplanung}
\label{sec:Kostenplanung}
Die Personalkosten belaufen sich auf ein Auszubildendengehalt, wodurch lediglich Stromkosten für die
zur Projekterstellung eingesetzte Hardware anfallen. Durch die ausschließliche Nutzung einer
Entwicklungsumgebung und Werkzeugen aus dem Open-Source-Bereich fallen keine zusätzlichen Kosten wie
Software-Lizenzen an.

\subsection{Entwicklungsprozess}
\label{sec:Entwicklungsprozess}
Der Entwicklungsprozess erfolgt \textit{test-driven}, was bedeutet dass vor dem Schreiben des eigentichen
Quellcodes einer Funktionalität zunächst der dazugehörige Test entwickelt wird. Diese Vorgehensweise
ermöglicht einen abstrakteren und zielorientierteren Blick auf die eigentlichen geforderten
Funktionen der Applikation, in dem als erstes eine Überlegung über das Ergebnis einer Funktion
und daraufhin die eigentliche Implementierung des jeweiligen Algorithmus erfolgt, welcher zu dem
gewünschten Ergebnis führt.

\subsection{Architekturdesign}
\label{sec:Architekturdesign}
Zur Umsetzung der geforderten Modularität der Applikation bietet sich das sogenannte
\textit{Model-View-Controller-Schema} (MVC) an. Dieses ist ein gängiges Schema beim Aufbau von Webapplikationen und
besteht aus drei Teilen:
\begin{itemize}
	\item das \textit{Model}, welches grob die einzelnen Tabellen einer Datenbank repräsentiert. Es enthält in
	der Regel zusätzliche Logik und Regeln, die zur Verwaltung und Zusammensetzung von Attributen
	eines Datenbankobjektes notwendig sind.
	\item der \textit{View}, welcher eine Ausgabe der gewünschten Daten bereitstellt. Im Kontext einer
	Webapplikation ist dies die eigentlich dargestellte Webseite in \textit{HTML/CSS}.
	\item der \textit{Controller}, welcher die Schnittstelle zwischen Model und View darstellt.
	Im Controller werden Eingaben verarbeitet und Befehle an das Model weitergegeben, welche
	die angeforderten Informationen an den Controller zurückgibt, der diese wiederum an den
	entsprechenden View verteilt.
\end{itemize}
Diese Aufteilung ermöglicht ein strukturierte und übersichtliche Entwicklung, da Funktionslogik,
Datenbankoperationen und Ausgabelogik klar getrennt und jeweils namentlich zugehörig gekennzeichnet
sind.

TODO: enter figure of MVC schematics

\subsubsection{Wahl der Programmiersprache}
\label{sec:Wahl der Programmiersprache}
Als Programmiersprache wurden \textit{Ruby} und das zugehörige Web-Framework \textit{Ruby on Rails}
gewählt.

Ruby basiert auf den Programmiersprachen Perl, Smalltalk, Eiffel, Ada und Lisp und legt Wert auf
die Balance von \textit{funktionaler} und \textit{imperativer Programmierung}. So verzichtet Ruby beispielsweise auf
Klammern zur Kennzeichnung von Codeblöcken und behandelt jeden Bestandteil des Codes, wie Variablen,
als ein \textit{Objekt}, welches eigene Methoden besitzt. Das macht die Verarbeitung und Manipulation von
Informationen sehr intuitiv und unterstreicht das Prinzip Rubys, den Programmierer nicht durch
Restriktionen und sprachlichen Eigenheiten bei seiner eigentlichen Arbeit zu behindern.

Ruby und sein Framework Ruby on Rails werden quelloffen verwaltet und entwickelt. Neben den
existierenden Programmbibliotheken existieren zusätzlich von der Community bereitgestellte Module,
sogenannte \textit{Gems}, welche wie kleine zusätzliche Bibliotheken behandelt werden können. Die
Einbindung dieser Gems in ein bestehendes Projekt vermeidet Duplikation und erspart viel
Entwicklungszeit.

\subsection{Benutzeroberfläche}
\label{sec:Benutzeroberfläche}
Da ohne die Mitwirkung eines darauf spezialisierten \textit{UI/UX}-Designers möglichst zeiteffizient
eine für Nutzer verständliche Oberfläche realisiert werden musste, fiel die Entscheidung auf
\textit{Twitter Bootstrap}.
Das CSS-Framework Twitter Bootstrap wird häufig zur Gestaltung von Webseiten und
-applikationen verwendet, da es ein über eine umfangreiche Bibliothek an Gestaltungsvorlagen
verfügt und sehr leicht in ein Projekt zu integrieren ist. Auch unerfahrenen Anwendern gelingt damit
mühelos ein ansprechende und responsive Nutzeroberfläche.

\subsection{Rechteverteilung}
\label{sec:Rechteverteilung}
Die Applikation soll von zwei verschiedenen Arten von Usern verwendet werden: dem regulären
Mitarbeiter, der einzig Zugriff auf seine verwalteten Informationen zu externen Services hat, und
einem Administrator, der neben der Bearbeitung seines eigenen Datensatzes auch jene aller in der
Datenbank vorhandenen Mitarbeiter einsehen, abfragen und löschen kann.

Diese Rechteverteilung kann über ein \textit{Flag} gelöst werden, was die einfachste Methode ist.
Sie ist allerdings aus sicherheitsrelevanter Sicht sehr anfällig und leicht zu manipulieren,
weswegen entschieden wurde, die Rechteverteilung auf Datenbankebene zu realisieren.

\subsection{Datenmodell}
\label{sec:Datenmodell}
Das Projekt verfügt grob über zwei Informationsträger, die in der Datenbank abgebildet werden
sollen: einen \textit{User} und ein zugehöriges \textit{Tool}.

TODO: insert ER-model

Da für die Applikation zusätzliche Spezialisierungen, wie eine Administrator-Rolle und verschiedene
externe Services, notwendig sind, wurden diese Beziehungen mit Hilfe der sogenannten
\textit{Single Table Inheritance} (STI) realisiert.

TODO: insert UML-Class-Model feat. STI

Diese spezielle Vererbungsstrategie lässt sich mit Hilfe der in Rails eingebauten
\textit{Active Record}-Engine durch das einfache Hinzufügen eines Typ-Attributs an das Model
umsetzen.

\subsection{Schnittstellen}
\label{sec:Schnittstellen}
Die Hauptaufgabe der Applikation ist die Bereitstellung der gesammelten Informationen zu den
Mitarbeitern und deren eingetragenen Informationen zu ihren genutzten Services. Dazu soll eine
eigene API innerhalb der Applikation entwickelt werden, welche die Informationen im \textit{JSON}-
Format ausgibt. Diese API kann nur authentifiziert angesprochen werden, d.h. der User muss eine
Administratorrolle besitzen, um Zugriff zur Schnittstelle zu erhalten.

\subsection{Paketierung}
\label{sec:Paketierung}
Gemäß der Richtline des Teams, in dem die Applikation entwickelt wurde, wird jene als \textit{RPM}
paketiert. Dies ermöglicht eine einfache und sofort funktionsfähige Installation, da alle
notwendigen Programmabhängigkeiten im Paket definiert und während des Installationsprozesses
abgerufen und mitinstalliert werden. Dadurch ist beispielsweise auch bei Bedarf eine problemlose 
Migration auf einen anderen Server möglich.
